#include <stdio.h>

// 변수의 종류
// 1. 지역변수
// 2. 전역변수
// 3. 정적변수(static)
// 4. 외부변수(extern)

// 메모리 영역
// 1. 스택 영역
// 2. 데이터 영역
// 3. 읽기 전용(코트, ROM)
// 4. 힙 영역

// 전역변수
int g_i = 0; // Data 영역

// Data 영역 특징
// 프로그램 시작 시 생성
// 프로그램 종료 시 해제

// void => 반환 타입이 없음.
void Test(); // 선언하지 않으면 main이 먼저 실행되기 때문에 선언해야함. (link 단계 에서 main 밑의 함수를 찾아 컴파일 진행)

// LNK오류코드 : 링크 오류
// C오류코드 : 컴파일 오류

#include "func.h"
#include "common.h"

// 헤더 파일에 함수 구현 시 다른 파일에서 같은 함수명을 사용한 경우 컴파일 전까진 문제가 되지 않으나, 링크 단계에서 문제가 발생한다.


int Test2()
{
	static int i = 0;
	++i;

	return i;
}

// 이후 Test2() 함수를 호출하면 i 값은 프로그램 시작 시 데이터 영역에 저장 된 후 Test2() 함수가 호출 될 때마다 1씩 증가한다.
// 외부 접근 불가 (포인터 사용으로 강제 접근은 가능)

int main5()
{
	g_iStatic = 100;
	g_iExtern = 500;

	// F12 : 선언 위치로 이동
	Add(0, 0);

	Test();
	Test();
	Test();

	Test2();
	Test2();
	Test2();
	Test2();
	int iCall = Test2();

	g_i = 0;
	printf("Test() 호출 횟수 : %d\n", iCall);
	// iCall => Test2() = 5

	int mulI = Mul(10, 20);

	// 포인터 변수
	// 주소를 저장하는, 가리키는 변수
	// 자료형 + *변수명
	// 해당 포인터에게 전달된 주소를 해석하는 단위
	// int* pInt = nullptr; => 아무것도 가리키지 않는다. 실제로 들어가는 데이터는 0
	int i = 100;
	float f = 3.f;

	//int* pInt = &i & : 변수의 주소를 저장
	int* pInt = (int*)&f; // => 강제 형변환으로 컴파일러 오류 무시했을 때 밑의 상황이 일어남

	// 주소로 접근
	(*pInt) = 100; // * : 주소에 있는 값을 가져옴
	i = *pInt; // => 2진수로 표현한 비트 값이 다르다.
			   // float 형의 3.f에 부동소수점을 포함 비트가 다르게 표현 되는데
			   // int 형의 관점으로 2진수를 10진수로 표현 했을 때 전혀 다른 값이 나오는 것
	// ex) int 형의 i에 4byte 크기의 f를 현재 비트 그대로 10진수로 해석하면 1,077,936,128이 나옴
	// => 자료형마다 비트를 해석하는 관점이 다르기 때문 (float의 관점에선 부동 소수점으로 사용되는 비트가 int 관점에선 그냥 2진법으로 표현한 정수일 뿐)

	// 주소의 단위
	// BYTE


	return 0;
}

void Test()
{
	// 지역변수
	int i = 0;
	++i;
	// => 함수 종료 시 메모리 해제

	// 전역변수
	++g_i;
	// => 프로그램 종료 시 메모리 해제
}